
装饰模式
一个抽象类具有很多的属性，属性采用一个抽象类代表，使用继承的方式装饰一个抽象类生成一个实体类。
那么这个实体类就装饰了最高层的抽象类。


Flyweight模式
采用共享对象的方法，复用对象，为用户服务。
为了能够复用，对象必须能够被保存。
可以采用HashMap的形式，用关键字保存对象，需要的时候取出来。

Bridge 模式
桥接，是为了降低耦合。
将实体和实体的实现方法分离开来。
一个抽象类代表一个实体，一个接口代表实体的动作，抽象类中包含接口的引用。
使用时，继承并创建抽象类的实例，传递接口的实例进去，那么，实体就能利用接口的方法动作起来。

Adapter 模式
适配两个接口，降低耦合性。
如果一个接口需要实现另一个接口的功能，只需添加适配器到实例中即可。

---------------行为模式－－－－－－－－－－－－

Memento 模式
备忘录模式的思想在于，将一个对象的状态备份起来供后续的查询和对象的复原。
而不是纯粹的重复创建对象，设置状态。重点在于一个对象的多种状态。

解释器模式（Interpreter）
大概应该这样一个意思，我们需要建立一套公式，当我们输入一定的规则时，公式会将需要的东西解释出来．
比如：１＋２＝？，解释器收到１解释成数字１，＋解释成需要将１和后面的内容相加，２解释成数字２，＝解释成需要求结果，然后将结果３返回．
同样的，可以解释一些别的东西，比如：解释一下这个人的性别？当输入一些特征后，解释器给出结果男或者是女．

观察者模式
一个接口被另一个接口观察着，一旦有什么特殊的情况，观察者自动给出响应。
比如：	计算机有一个鼠标被一个观察者观察，如果鼠标动了，观察者就把“动了的实际表现”显示在显示器上。
		这个可以是一个主动也可以是一个被动的观察者，主动的响应速度会更快。

中介模式(mediator pattern)
与代理模式的思想大同小异，区别在于。
1. 中介模式强调的是，先创建一个具体的对象，然后引进一个另外的对象，帮忙处理一个事情。
2. 代理模式强调的是，压根就没有具体的对象，而是创建一个代理，让代理完成自己想要做的事情。代理呢，就创建一个用户需要的对象，然后让这个对象做事情，它自己却不做。

职责链模式（chain of responsibility）
1. 首先工作的对象组成一条链。
2. 链具有level，完成不了递给链中的下一级。




装饰模式
一个抽象类具有很多的属性，属性采用一个抽象类代表，使用继承的方式装饰一个抽象类生成一个实体类。
那么这个实体类就装饰了最高层的抽象类。


Flyweight模式
采用共享对象的方法，复用对象，为用户服务。
为了能够复用，对象必须能够被保存。
可以采用HashMap的形式，用关键字保存对象，需要的时候取出来。

Bridge 模式
桥接，是为了降低耦合。
将实体和实体的实现方法分离开来。
一个抽象类代表一个实体，一个接口代表实体的动作，抽象类中包含接口的引用。
使用时，继承并创建抽象类的实例，传递接口的实例进去，那么，实体就能利用接口的方法动作起来。

Adapter 模式
适配两个接口，降低耦合性。
如果一个接口需要实现另一个接口的功能，只需添加适配器到实例中即可。

---------------行为模式－－－－－－－－－－－－

Memento 模式
备忘录模式的思想在于，将一个对象的状态备份起来供后续的查询和对象的复原。
而不是纯粹的重复创建对象，设置状态。重点在于一个对象的多种状态。

解释器模式（Interpreter）
大概应该这样一个意思，我们需要建立一套公式，当我们输入一定的规则时，公式会将需要的东西解释出来．
比如：１＋２＝？，解释器收到１解释成数字１，＋解释成需要将１和后面的内容相加，２解释成数字２，＝解释成需要求结果，然后将结果３返回．
同样的，可以解释一些别的东西，比如：解释一下这个人的性别？当输入一些特征后，解释器给出结果男或者是女．

访问者模式(visitor)
一个接口邀请另一个接口，访问者访问后给出响应。
比如：	计算机有一个鼠标邀请访问者访问，当访问者到来的时候，给出一定的动作，访问者就把“动了的实际表现”显示在显示器上。
注意：必须受到邀请才能访问。
区别于观察者模式。

中介模式(mediator pattern)
与代理模式的思想大同小异，区别在于。
1. 中介模式强调的是，先创建一个具体的对象，然后引进一个另外的对象，帮忙处理一个事情。
2. 代理模式强调的是，压根就没有具体的对象，而是创建一个代理，让代理完成自己想要做的事情。代理呢，就创建一个用户需要的对象，然后让这个对象做事情，它自己却不做。

职责链模式（chain of responsibility）
1. 首先工作的对象组成一条链。
2. 链具有level，完成不了递给链中的下一级。


状态模式（state pattern）
1. 一个对象
2. 这个对象具有一个属性，叫状态
3. 这个对象希望可以动态改变自己的状态以适应环境
注意思考：
这个对象的行为是在对象类中进行还是在状态类中进行呢？
在状态类中进行是个不错的选择。

命令模式（command pattern）
1. 有一个作为命令接口
2. 有一个执行命令的对象,这个对象包含一个允许执行的命令集
3. 实现命令接口，执行对象内的命令集中的命令
4. 提供一个管理命令的类，基本包含添加命令，按照一定的方式执行命令。
具体是这样的：
创建命令对象，携带操作对象，创建管理员管理命令，管理员发布命令，命令驱动操作对象。
由于不同的命令触发对象对应的不同的动作，所以，我们可以通过命令来驱动对象行为。

模板模式（template pattern）
提供一个虚拟类作为模板，其它的子类都模仿。太简单，不阐述了。

观察者模式（observer pattern）
一个对象被另一个观察者观察，观察者观察到变化就会通知需要信息的对象。
问题：
观察者如何知道变化了？
答：
被观察的对象告诉它的，因为这个观察者这不够智能。
点评：
将那些需要信息的对象当作无关对象，减少了对象本身与无关对象的耦合性，很棒。
观察这可以很多，不同功能的观察者负责不同的观察内容，分工明确，可维护性强。

迭代器模式（Interator pattern）
1. 使用一个接口A迭代另一个接口B
2. A是B的迭代器，我们希望由B提供它的实现，最好是别人无法修改这个实现

原型模式(prototype pattern)
原型模式，也理解为克隆模式，需要继承JAVA中的Cloneable接口。
克隆仅仅是简单的复制对象，并不会产生新的对象。

